---
类型: " 笔记"
时间: 2024-01-22T11:08:00 
父类标识: C++ prime plus笔记
---
## 整型
整形包括多种，如short、int、char、long和longlong，但是没有一种选择能够满足所有计算机的要求。C++提供了一种灵活的标准，他确保了最小长度，如下：
- short至少16位
- int至少与short一样长
- long至少32位，且至少与int一样长
- long long至少64位，且至少与long一样长
```c++
#include<iostream>

#include<climits>

int main(){

    using namespace std;

    int n_int=INT_MAX;

    short n_short=SHRT_MAX;

    long n_long=LONG_MAX;

    long long n_llong=LLONG_MAX;

  

    cout<<"int is "<<sizeof(int)<<" byte."<<endl;

    cout<<"short is "<<sizeof(short)<<" byte."<<endl;

    cout<<"long is "<<sizeof(long)<<" byte."<<endl;

    cout<<"long long is "<<sizeof(long)<<" byte."<<endl;

  

    cout<<endl;

  

    cout<<"Maximum values:"<<endl;

    cout<<"int:"<<n_int<<endl;

    cout<<"short:"<<n_short<<endl;

    cout<<"long:"<<n_long<<endl;

    cout<<"long long:"<<n_llong<<endl;

  

    return 0;

  

}
```
![[limits.cpp]]
## 初始化
如果不对函数内部定义的变量初始化，那么该变量的值是不确定的，这意味着该变量的值将是它被创建前，相应内存单元所保留的值。
C++提供了大括号**初始化器**（可以使用等号也可以不使用），这种初始化器可以用于任何类型，这是一种通用的初始化语法
## 无符号类型
```c++
#include<iostream>

#include<climits>

int main(){

    using namespace std;

    int n_int=INT_MAX;

    short n_short=SHRT_MAX;

    long n_long=LONG_MAX;

    long long n_llong=LLONG_MAX;

  

    cout<<"int is "<<sizeof(int)<<" byte."<<endl;

    cout<<"short is "<<sizeof(short)<<" byte."<<endl;

    cout<<"long is "<<sizeof(long)<<" byte."<<endl;

    cout<<"long long is "<<sizeof(long)<<" byte."<<endl;

  

    cout<<endl;

  

    cout<<"Maximum values:"<<endl;

    cout<<"int:"<<n_int<<endl;

    cout<<"short:"<<n_short<<endl;

    cout<<"long:"<<n_long<<endl;

    cout<<"long long:"<<n_llong<<endl;

  

    return 0;

  

}
```
![[unsigned.cpp]]
## 选择整型类型
int通常被设置为对目标计算机而言最为“自然”的长度，**自然长度**（natural size）是指计算机处理起来效率最高的长度。
如果目标变量非负，可以使用**无符号类型**（unsigned）
如果可能大于16位整数，则使用long
如果存储的值超过20亿，则使用long long
由于short比int小，使用short可以更节省内存。通常，只有大型整型数组采用short。如果只需要一个字，可以使用char。
## 整型字面值
- 8进制：第一位是0后两位是1~7
- 16进制：前两位是0x或0X
在默认情况下，cout以十进制格式显示整数，而不管这些整数在程序中是如何书写的。如果想用十六进制或八进制的形式显示，可以使用控制符dec、hex和oct。
```c++
#include<iostream>

using namespace std;

int main(){

    int chest=42;

    int waist=42;

    int inseam=42;

  

    cout<<"Monsieur cuts a striking figure!"<<endl;

    cout<<"chest= "<<chest<<" (decimal for 42)"<<endl;

    cout<<hex;

    cout<<"waist= "<<waist<<" (hexadeciaml for 42)"<<endl;

    cout<<oct;

    cout<<"inseam= "<<inseam<<" (octal for 42)"<<endl;

    return 0;

}
```
诸如hex，oct这些代码会修改cout显示整数的方式。
## 如何确定常量的类型
| 类型              | 后缀                     | 例子             |
| ----------------- | ------------------------ | ---------------- |
| int               | --                       | --               |
| unsigned int      | u or U                   | 99u or99U        |
| long              | l or L                   | 99l or 99L       |
| unsigned long     | ul or UL or LU           | 2022LU or 2022UL |
| long long         | ll or LL                 | 2022LL or 2022LL |
| usigned long long | ull or Ull or uLL or ULL |                  |

## 通用字符名
C++有一种表示特殊字符的机制，它独立于所有特定的键盘，使用的是**通用字符名**（universal character name）
通用字符名以\u或\U打头，\u后面是4个十六进制位，\U后面是8个十六进制位，这些位表示的是字符的ISO 10646码点。
如ö的ISO 10646码点是00F6
```c++
#include<iostream>

using namespace std;

int main(){

    cout<<"g\u00F6e";


}
```
# const限定符
相比于#define，const可以明确的指出类型，其次能够将作用域的规则用于常量。
# 浮点数
## 浮点数表示方法
- 标准的小数点表示法：12.34
- E表示法：3.45E6，这指的是3.45与10的六次方相乘，既可以使用E也可以使用e
## 浮点数类型
| 类型        | 有效位数 |
| ----------- | -------- |
| float       | 至少32位，通常32位 |
| double      | 至少48位，通常64位 |
| long double |     一般为80，96，128位     |
## 浮点常量
| 类型        | 后缀           |
| ----------- | -------------- |
| float       | f or F         |
| double      | 默认情况下都是 |
| long double | l or L         |
# 算术运算符
## 运算符的优先级和结合性
- 优先级：即谁先参与运算
- 结合性：从左到右的结合性意味着如果两个优先级相同的运算符被用于同一个操作数，则首先应用左侧的运算符。
## 除法分支
浮点数在默认情况下都是double类型
```c++
#include<iostream>

int main(){

    using namespace std;

    cout.setf(ios_base::fixed,ios_base::floatfield);

    cout<<"Integer division: 9/5= "<<9/5<<endl;

    cout<<"Floating-point division: 9.0/5.0= "<<9.0/5.0<<endl;

    cout<<"Mixed division: 9.0/5= "<<9.0/5<<endl;

    cout<<"double constants: 1e7/9.0= "<<1e7/9.0<<endl;

    cout<<"float constants: 1e7f/9.0f= "<<1e7f/9.0f<<endl;

    return 0;

}
```
## 求模运算符
常用于解决要求将一个量分为不同的整数单元的问题，例如将英寸分为英寸+英尺。
```c++
#include<iostream>

int main(){

    using namespace std;

    const int Lbs_per_stn=14;

    int lbs;

  
  

    cout<<"Enter you weight in pounds: ";

    cin>>lbs;

    int stone=lbs/Lbs_per_stn;

    int pounds=lbs%Lbs_per_stn;

    cout<<lbs<<" pound are "<<stone<<" stone, "<<pounds<<" pound(s).\n";

    return 0;

}
```
## 类型转换
- 赋值初始化的转换：允许将小范围值转化为大范围值，也允许将大范围值转化为小范围值，只不过值会不准确
  ```c++
  #include<iostream>

int main(){

    using namespace std;

    cout.setf(ios_base::fixed,ios_base::floatfield);

    float tree=3;//int converted to float

    int guess(3.9832);//double converted to int

    int debt=7.2e12;//result not defined in c++

    //overflow in conversion from 'double'

    //to 'int' changes value from '7.2e+12' to '2147483647' [-Woverflow]gcc

    cout<<"tree= "<<tree<<endl;

    cout<<"guess= "<<guess<<endl;

    cout<<"debt= "<<debt<<endl;

    return 0;

}
  ```
- {}列表初始化的转换：类型转换更加严格，列表初始化不允许缩窄（narrowing），即变量的类型可能无法表示赋给它的值
  ```c++
  #include<iostream>

using namespace std;

int main(){

    const int code=66;

    int x=66;

    char c1{31325};//narrowing not allow

    //narrowing conversion of '31325' from 'int' to 'char' [-Wnarrowing]gcc

    char c2={66};//allow because char can hold 66

    char c3{code};//ditto

    char c4{x};//not allow, x is not constant

    //narrowing conversion of 'x' from 'int' to 'char' [-Wnarrowing]gcc

    //编译器这样报错，可能跟c标准有关系

    x=31325;

    char c5=x;//allowed by this form of initialization

}
  ```
- 表达式中的转换：cpp中有两种转换，一种是特定类型在出现时就会被自动转换，cpp将bool, char, unsigned char, signed char, short转换为int，称为**整型提升**（integral promotion），如果short和int长度相同，unsigned short会转变为unsigned int以保证不丢失数据，同样wchar_t也会被提升（提升成：int,unsigned int,long,unsigned long）成第一个宽度足够存放wchar_t的类型 ；另一种转换是不同类型进行运算时，编译器通过校验表来确定所执行的转换。
  <center>校验表  </center>
	  1. 如果有一个操作数的类型是long double，则将另一个操作数转换为long double
	  2. 否则，如果有一个操作数的类型是double，则将另一个操作数转换为double
	  3. 否则，如果有一个操作数的类型是float，则将另一个操作数转换为float
	  4. 否则，说明操作数都是整型，因此进行整型提升
	  5. 在这种情况下，如果两个操作数都是有符号或无符号的，且其中一个级别更低，则转化为更高的级别
	  6. 如果一个操作数是无符号的，一个是有符号的，且无符号的操作数级别要比有符号操作数高，则将有符号的操作数转换为无符号的操作数
	  7. 否则，如果有符号的类型可以表示无符号类型的所有可能取值，则将无符号操作数转换为有符号的操作数所属的类型。
	  8. 否则，将两个操作数都转化为有符号类型的无符号版
- 传递参数时的转换：通常由函数原型控制
- 强制类型转换：这种转换不会改变源值本身，而是创建一个新的值，在表达式中使用`(typename)value or typename(value)`。cpp还提供了4种运算符用来强制类型转换，他们对使用的要求更加严格。
## auto声明
  auto能根据初始值的类型推断变量的类型。auto在处理复杂类型时自动推断的优势才显现出来，比如标准库模块STL中的类型
  