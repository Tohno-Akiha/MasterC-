# 派生类
## 类继承的语法
```c++
class class1{
	int a;
	int b;
}
class subclass1:public class1{
	int c;
	int d;
}
```
subclass1就是一个派生类，public表明这是一个公有派生，基类的公有成员将成为派生类的公有成员；基类的私有成员也会成为派生类的一部分，但是只能通过基类的公有方法和保护方法访问。
## 构造函数
派生类的构造函数必须使用基类的构造函数才能初始化基类成员，也可以认为创建派生类之前程序首先创建基类对象。
```c++
class1::class1(int a,int b){

}
subclass1::subclass1(int a,int b,int c,int d):class1(a,b){

}
```
派生类使用成员初始化列表来调用基类的构造函数，如果省略这一步，将会调用默认的构造函数。复制构造函数也是一样的。
## 基类指向派生类对象
基类指针可以在不显式进行类型转换的情况下指向派生类对象；基类引用也可以在不进行显式类型转换的情况下指向派生类对象。相当于默认定义了一个转换函数，由派生类转换成基类。这被称为向下转型。
然而，基类指针只能调用基类方法， 并且派生类不能指向基类。
可以使用派生类对象初始化基类对象，这将调用基类对象的默认复制构造函数。同样也能够将派生类对象赋值给基类对象。
# 多态公有继承
## 虚函数
基类指针能够指向派生类，而这个指针只能访问基类中的方法。
```c++
class base{
public:
	func(){}
}
class sub{
public:
	func(){}
}
base * prt=new sub();
prt->func();//func() is in class base
```
使用关键字virtual能够将成员函数声明为虚方法，程序将根据引用或指针指向的对象类型来选择方法。
```c++
class base{
public:
	virtual func(){}
}
class sub{
public:
	virtual func(){}
}
base * prt=new sub();
prt->func();//func() is in class sub
```
实际上当方法被声明成虚的时候，在派生类中会被自动声明成虚方法，也可以显式的在派生类中指出哪些方法是虚方法。
virtual声明只用于类声明的方法原型中，而没有用于方法的定义中。
## 虚析构函数
使用虚析构函数能够保证正确的析构函数序列被调用，如果基类指针指向的是一个派生类，那么将会调用这个派生类的析构函数。因此析构函数一般都被声明成虚函数。
# 访问控制protected
protected与private类似，在类外只能使用共有类成员来访问protected中定义的成员。派生类的成员可以直接访问基类的保护成员，但不能直接访问基类的私有成员。
使用保护成员看似可以简化代码的编写工作，但是有设计缺陷。假设一个保护成员被设计成只能通过公共成员函数才能访问，但是对于派生类直接就可以访问保护成员，事实上该成员成为了一个公有变量。
所以最好对数据成员采用私有访问控制，不要保护访问控制。然而对于成员函数来说，保护访问控制很有用。
# 抽象基类
C++使用纯虚函数提供未实现的函数，纯虚函数声明处的结尾为=0
```c++
class base{
virtual func() =0;
}
```
在原型中使用=0指出类是一个抽象类，在类中可以不定义该函数。
# 继承和动态内存分配
## 派生类不使用new
派生类的默认析构函数在执行万自身的代码之后会调用基类析构函数。因此，如果派生类不使用new，我们不许要执行任何操作。
默认复制构造函数对于使用动态内存分配的类来说是不合适的，而如果派生类不使用new，将会调用默认复制构造函数，这个复制构造函数将会调用基类的复制构造函数。
对于赋值来说也是如此。类的默认复制运算符将自动使用积累的赋值运算符来对基类组件进行赋值。
## 派生类使用new
这种情况下必须显式的定义析构函数、复制构造函数和赋值运算符。
派生类自动调用父类析构函数，故其自身的职责是对派生类构造函数执行的工作进行清理。
复制构造函数使用初始化列表来调用基类的复制构造函数：
```c++
base::base(const base &b){
...
}
sub::sub(const sub &s):base(s){
...
}
```
赋值运算符显示的调用基类赋值运算符：
```c++
sub &sub::operator=(const sub &su){
...
base::operator=(su);
...
}

```
这里的赋值运算符使用的是函数形式，如果直接赋值运算符调用的是该函数自己，这回产生无限的递归调用。
## 访问友元
派生类如何访问基类的友元？因为友元不是成员函数，因此不能使用作用域解析运算符来指出要使用的是那个函数，这个问题的解决方法是使用强制类型转换，将派生类强制转换成基类来匹配友元的原型。