# 存储持续性作用域和链接性
- 持续性：生命周期
- 作用域：变量名可见的范围
- 链接性：是否能被其它文件调用
## 自动存储持续性
在函数中声明的函数参数和存储持续性为<mark style="background: #FF5582A6;">自动</mark>，作用域为<mark style="background: #FF5582A6;">局部</mark>，没有链接性。
所谓自动即在程序开始执行其所属的函数或代码块时被创建，执行完之后就被释放
编译器使用栈来存储自动变量，程序使用两个指针来跟踪栈，一个指向栈顶，一个指向栈底。
可以使用关键字`register`来显式的指出变量是自动变量。
## 静态持续变量
与自动变量相比，静态变量的声明周期更长，它在整个程序执行过程中都存在，这不意味着它不受作用域限制，而是说它在作用域之外不可见但是其内存没有被释放。编译器分配固定的内存块来存储所有的静态变量，这些变量在整个程序执行期间一直存在。
静态存储有三种链接性：外部链接性（可以在其他文件中访问）、内部链接性（只能在当前文件中访问）、无链接性（只能在当前函数或代码块中访问）
```c++
int global=1000;              //static duration, external linkage
static int one_file=50;       //static duration, internal linkage
int main(){
	...
}
void func1(){
	static int count=0;       //static duartion, no linkage
}
```
五种变量存储方式：

| 存储描述         | 持续性 | 作用域 | 链接性 | 如何声明                         |
| ---------------- | ------ | ------ | ------ | -------------------------------- |
| 自动             | 自动   | 代码块 | 无     | 在代码块中                       |
| 寄存器           | 自动   | 代码块 | 无     | 在代码块中，使用关键字register   |
| 静态、无链接性   | 静态   | 代码块 | 无     | 在代码块中，使用关键字static     |
| 静态、外部链接性 | 静态   | 文件   | 内部   | 不在任何函数中                   |
| 静态、内部链接性 | 静态   | 文件   | 内部   | 不在任何函数中，使用关键字static |

## 静态持续性、外部链接性
链接性为外部的变量称为外部变量或全局变量。
cpp中遵循单定义规则，该规则指出，变量只能有一次定义。cpp为变量提供了两种声明，一种是定义声明，即定义，它给变量分配内存空间；另一种是引用声明，即声明，他不会给变量分配内存空间，因为它引用已有的变量。
引用声明使用关键字extern，且不进行初始化，否则，声明变为定义，分配内存空间。就是说`extern int i=99`算作变量的定义。
可以使用作用域解析运算符（::）来使用变量的全局版本，如`::i`
## 静态持续性、内部链接性
由于单定义规则，在同一目录下的文件中你只能定义一个外部变量，如：
```c++
//file1
int errors=20;
//file2
int errors=20;
```
上面这种做法当然是不行的，但是我们可以定义一个静态外部变量，在该文件中静态外部变量将会隐藏常规外部变量：
```c++
//file1
int errors=20;
//file2
static int errors=20;
```
## 静态持续性、无链接性
无链接性的变量只能在作用域内使用，但是它在程序运行时仍然存在于内存中，因此在两次函数调用之间，静态局部变量的值将会保持不变
```c++
#include<iostream>

void show();

int main(){

    using namespace std;

    show();

    show();

    show();

    show();

    show();

    show();

  

}

void show(){

    static int i=0;

    std::cout<<i++<<std::endl;

}
```
## 说明符和限定符
 有些被称为存储说明符cpp关键字提供了其他有关存储的信息：
- ~~auto~~（在c+11中已经不作为说明符）：自动类型推断
- ~~register~~：声明自动变量
- static：在作用域是整个文件的时候，用于表示链接性；在用于局部声名时，表示变量是静态的
- extern：引用声明
- thread_local：指出变量的持续性与其所属线程相同
- mutable：与const有关
### cv-限定符
cv表示const和volatile。
const表明内存被初始化后，程序将不能对它进行修改；
volatile表明，即使程序没有对内存单元进行修改，其值也会发生变化，它通常被用在改善编译器性能上
### mutable
mutable可以指出，即使结构或类是const，其某个成员也可以被修改，例如：
```c++
struct data{
	char name[20];
	mutable int accesses;
};
const data veep={"Claybourne Clodde",0,...};
veep.accesses++;
```
### const
在cpp中const会对默认存储类型有一定的影响，在默认情况下全局变量的链接性是外部的，但是<mark style="background: #FF5582A6;">const全局变量的链接性为内部的</mark>，也就是说，全局const定义就相当于使用了static说明符一样。
这种特性会使开发更加轻松，例如在一个程序的不同文件中使用某一个头文件，该头文件定义了一个常量，如果链接性是外部的，则会出错，这违反了单定义规则。就必须先在某个文件中定义，再在其他文件中使用extern声明。
```c++
//xxx.h
const int a=10;
const int b=20;
//file1.cpp
extern const int a;
extern const int b;
```
另外，只有没有使用extern关键字的常量能够初始化
如果出于某种原因，需要某个常量的链接性为外部的，则可以使用extern关键字来覆盖默认的链接性
```c++
extern const int  a=10;
```
## 函数和链接性
与变量一样函数也具有链接性，虽然可选择的范围很小。因为函数中不能定义函数，因此所有函数的存储持续性都是自动为静态的，也就是说，在程序整个执行期间都会一直存在。在默认情况下，函数的链接性为外部的，即可以在文件间共享。实际上可以在函数原型中使用extern关键字来指出函数是在另外一个文件中定义的，不过这是可选的（要让程序在一个文件中查找函数，该文件必须作为程序的组成部分被编译，或者是由链接程序搜索的库文件）。
需要注意的是，如果要在另一个文件中使用别的函数，那么必须要先进行函数的声明。
<mark style="background: #FF5582A6;">还可以使用static使函数的链接性定义为内部的</mark>，使之只能在一个文件中使用，同时在原型和函数中使用该关键字：
```c++
static int private(int t);
...
static int private(int t){
	...
}
```
这意味着该函数只在这个文件中可见，和变量一样，定义静态函数的文件中，静态函数将会覆盖外部定义。
内联函数不受外部链接性的制约，这允许将内联函数的定义放到头文件中，这样包含了头文件的每个文件都有函数的定义。
## 语言链接性
语言链接性对函数也有影响，链接程序要求每个不同的函数名有不同的符号名。在c中，一个名称值对应一个函数，因此这很容易实现，比如将spiff这样的函数名翻译成_sniff。但是在cpp中，由于重载及其他特性，同一个名称可能对应多个函数，必须将这些函数翻译成不同的符号名称。
如果由于c和cpp使用的查询约定不同，因此我们在使用c库的文件中可以使用函数原型来指出要使用的约定：
```c++
extern "C" void spiff(int);   //use C protocol for name look up
extern void spiff(int);      //use C++ protocol for name look up
extern "C++" void spiff(int);//use C++ protocol for name lool up
```
## 动态分配
使用new初始化：
```c++
int *pi=new int(5);
double *pd=new double(1.1);
struct where{double x,double y, double z};
where *one=new where{2.1,2.5,2.4};
int *ar=new int[4]{1,2,3,4};
int *pi2=new int{5};
double *pd2=new double{2.1};
```
new可能找不到请求的内存量，将引发异常std::bad_alloc
new运算符和new[]运算符分别调用如下函数：
```c++
void *operator new(std::size_t);
void *operator new[](std::size_t);
```
同样的delet运算符调用释放函数：
```c++
void operator delete(void*);
void operator delete[](void*);
```
## 定位new运算符
定位new可以让你指定要使用的位置。要使用定位new就必须包含new头文件，定位new使用传递给它的地址，但是他不跟踪哪些内存块已经被使用，也不查找未被使用的内存块。
```c++
// newplace.cpp -- using placement new

#include <iostream>

#include <new> // for placement new

const int BUF = 512;

const int N = 5;

char buffer[BUF];      // chunk of memory

int main()

{

    using namespace std;

  

    double *pd1, *pd2;

    int i;

    cout << "Calling new and placement new:\n";

    pd1 = new double[N];           // use heap

    pd2 = new (buffer) double[N];  // use buffer array

    for (i = 0; i < N; i++)

        pd2[i] = pd1[i] = 1000 + 20.0 * i;

    cout << "Memory addresses:\n" << "  heap: " << pd1

        << "  static: " <<  (void *) buffer  <<endl;

    cout << "Memory contents:\n";

    for (i = 0; i < N; i++)

    {

        cout << pd1[i] << " at " << &pd1[i] << "; ";

        cout << pd2[i] << " at " << &pd2[i] << endl;

    }

  

    cout << "\nCalling new and placement new a second time:\n";

    double *pd3, *pd4;

    pd3= new double[N];            // find new address

    pd4 = new (buffer) double[N];  // overwrite old data

    for (i = 0; i < N; i++)

        pd4[i] = pd3[i] = 1000 + 40.0 * i;

    cout << "Memory contents:\n";

    for (i = 0; i < N; i++)

    {

        cout << pd3[i] << " at " << &pd3[i] << "; ";

        cout << pd4[i] << " at " << &pd4[i] << endl;

    }

  

    cout << "\nCalling new and placement new a third time:\n";

    delete [] pd1;

    pd1= new double[N];

    pd2 = new (buffer + N * sizeof(double)) double[N];

    for (i = 0; i < N; i++)

        pd2[i] = pd1[i] = 1000 + 60.0 * i;

    cout << "Memory contents:\n";

    for (i = 0; i < N; i++)

    {

        cout << pd1[i] << " at " << &pd1[i] << "; ";

        cout << pd2[i] << " at " << &pd2[i] << endl;

    }

    delete [] pd1;

    delete [] pd3;

    // cin.get();

    return 0;

}
```
# 名称空间
在C++中名称可以是变量、函数、结构、枚举、类以及结构的成员。随着项目的增大，名称相互冲突的可能性也大大增加。
名称空间可以是全局的也可以位于另一个名称空间中，但不能位于代码块中。因此，默认情况下名称空间的链接性是外部的。除了用户定义的名称空间外，还有一个**全局名称空间**。它对应于文件级声明区域，因此前面所说的全局变量位于全局名称空间中。
假设名称空间和生命区域中定义了相同的名称，如果使用using声明，则两个名称会发生冲突；如果使用using编译指令，则局部版本将隐藏命名空间版本。
 还存在未命名的名称空间，也就是说该名称空间相当于链接性为内部的静态变量。