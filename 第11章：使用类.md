# 重载运算符
## 重载运算符的定义
ｃｐｐ允许将运算符重载到用户定义的类型。要重载运算符需要使用称为运算符函数的特殊函数形式。运算符函数的格式如下：
```c++
operatorop(argument-list);
```
例如：
```c++
Time Time::operator+(const Time& t) const {
	Time sum;
	sum.minutes = this->minutes + t.minutes;
	sum.hours = this->hours + t.hours + sum.minutes / 60;
	sum.minutes %= 60;
	return sum;
}
total=coding.operator+(fixing);
total=coding+fixing;
```
需要注意的是，在运算符表示法中，运算符左侧的对象是调用对象，运算符右侧的对象是作为参数被传递的对象。
## 重载运算符限制
C++对于用户定义的重载运算符有一定的限制：
1. 重载后的运算符必须有一个操作数是用户定义的类型，浙江纺织用户为标准类型重载运算符。
2. 使用运算符时不能违反运算符原来的语法，比如将双操作数的运算符重载成单操作数的
3. 不能新建新运算符
4. 不能重载下面的运算符：
   ```c++
   sizeof//sizeof运算符
   .//成员运算符
   .*//成员指针运算符
   :://作用域运算符
   ?://条件运算符
   typeid//一个强RTTI运算符
   const_cast//强制类型转换运算符
   dynamic_cast//强制类型转换运算符
   reinterpret_cast//强制类型转换运算符
   static_cast//强制类型转换运算符
```
5. 大多数运算符都能通过成员函数或非成员函数重载，但是下面的运算符只能通过成员函数重载
   =,(),[],->
   ## 友元函数
   通过让函数成为类的友元，可以赋予与该函数与类成员函数相同的访问控制权限。在重载二元运算符的时候常常需要友元，二元运算符有时候会遇到左右操作数不是同一个类型的情况，例如：
```c++
   Time Time::operator*(double mult) const {
	Time result;
	long totalminutes = hours * mult * 60 + minutes * mult;
	result.hours = totalminutes / 60;
	result.minutes = totalminutes % 60;
	return result;
}

```
这种重载可以计算下面的例子：
```c++
Time A;
Time B;
A=B*2.75;//B.operator*(2.75)
```
但是对于下面这种就无法匹配：
```c++
A=2.75*B;
```
解决这种问题的一个方法是非成员函数，这是这个非成员函数的原型：
```c++
Time operator*(double m,const Time&t);
```
但是非成员函数不能直接访问类的私有数据，因此引入了友元。
## 创建友元
将原型放在类声明中，并在原型声明前加上friend关键字：
```c++
friend Time operator*(double m,const Time &t);
```
虽然operator\*是在类中声明的，但它不是成员函数，不能通过成员运算符来访问，不过它与成员函数有着相同的访问权限。
接下来是编写函数定义，由于operator\*不是成员函数，因此不需要使用作用域运算符：：。
```c++
Time operator*(double m,const Time &t){
	Time result;
	long totalminutes=t.hours*m*60+t.minutes*m;
	result.hours=totalminutes/60;
	result.minutes=totalminutes%60;
	return result;
}
```
## 常用友元<<重载
<<需要使用友元进行重载，因为操作数的左侧一般都是一个ostream对象，而成员函数的运算符重载左侧是调用对象，右侧是传递的参数，这会形成很尴尬的场面：
```c++
Time<<cout
```
使用友元重载如下：
```c++
std::ostream &operator<<(std::ostream &os,const Time&t){
	os<<t.hours<<" hours"<<t.minutes<<" minutes";
	return os;
}
```
# 类的强制类型转换和自动转换
## 构造函数转换
可以将类定义成与一个基本类型或一个类相关，使得从一种类型转换成另一种类型是有意义的。
```c++
class Stonewt {
private:
	enum{Lbs_per_stn=14};
	int stone;
	double pds_left;
	double pounds;
public:
	Stonewt(double lbs);
	Stonewt(int stn, double lbs);
};
```
可以使用构造函数实现类型转换：
```c++
Stonewt myCat;
myCat=19.6;
myCat=Stonewt(19.6);
myCat=(19.6)Stonewt;
```
这一过程是隐式自动类型转换，如果构造函数有两个参数，就不能作为转换函数，但是给第二个参数提供默认值的话，也能作为转换函数。
C++提供了关键字explicit来关闭这种特性，当使用了关键字explicit限定了构造函数：
```c++
explicit Stonewt();
```
 构造函数将只适用于显式强制类型转换。
需要格外注意的是，函数原型提供参数匹配过程，允许使用`Stonewt(double)`来转换类型，这是在仅当转换不存在二义性的时候才会进行的，也就是说，如果定义了`Stonewt(long)`编译器将拒绝这些语句。
## 转换函数
可以将数字转换成Stonewt对象，也能反过来，这就需要借助转换函数。
```c++
operator typeName();
```
需要注意的是：
1. 转换函数必须是类方法
2. 转换函数不能指定返回类型
3. 转换函数不能有参数
