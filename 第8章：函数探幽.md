# 内联函数
常规函数通过[[第2章：指令#^e4a8e8|跳转]]来实现函数的调用，而内联函数提供了另一种选择，将内联函数编译的代码与其他程序代码“内联起来了”，也就是说编译器通过使用相应的函数代码替换函数调用。内联函数通常比其他函数运行的速度要快，但是代价是需要占用更多的内存。应该有选择的调用内联函数，如果代码的执行时间比处理函数调用的机制的时间更长，则节省的时间将只占这个过程的一小部分。如果代码的执行时间短，则内联调用就会节省非内联调用所使用的大部分时间。尽管节省了该过程的大部分时间，但是节省时间的绝对值并不大。
 要使用这项特性需要采取以下的措施之一：
 - 在函数声明前加上关键字inline
 - 在函数定义前加上关键字inline
 通常的做法是省略原型，将整个定义放在本应该提供原型的地方。
 ```c++
 inline double square(double x){
	 return x*x;
 }
 ```
 输出表明，内联函数和常规函数一样，都是按值来传递参数的。这使得cpp的内联函数远远胜过c语言的宏。
 C语言使用预处理器#define来定义宏
 ```c++
 #define SQUARE(X) X*X
 ```
 这并不是通过传递参数来实现的，而是通过文本替换来实现的
 ```c++
 a=SQUARE(5.0); //replaced by a=5.0\*5.0
 b=SQUARE(4.5+7.5);//repalced by b=4.5+7.5\*4.5+7.5
 c=SQUARE(i++);//repalced by c=i++*i++
 ```
 可以使用括号来进行改进#define SQUARE(X) ((X)\*(X))，但是仍然存在新的问题，即宏的值不能传递。即使使用新的定义，SQUARE(i++)仍然将变量i递增两次
 # 引用变量
 ## 创建引用变量
 cpp给符号&赋予了另外一个含义，将其用来声明引用。
 ```c++
 int rats;
 int &rodents=rats;
 ```
其中&不是地址运算符，而是**标识符**的一部分，上述引用声明允许rats和rodents互换，他们指向相同的值和内存单元。引用看上去像是伪装过后的指针，但其实他们两个之间有一些区别。必须在声明引用时将它初始化，而不能像指针一样先声明再赋值。
 ```c++
 int rats=10;
 int &rodent;
 rodent=rat;//invalid
 ```
 引用更接近const指针，必须在创建时进行初始化，一旦与某个变量关联起来，就将一直效忠于它。
 ```c++
 int &rodent=rats;
 int *const pr=&rats;
 ```
 使用=运算符并不会改变引用的值，比如：
 ```c++
 int bunnies;
 rodent=bunnies;
 ```
 这种赋值操作只会更改rats自己本身的值，而不会将引用指向另外一个变量，因为rodent是rats的别名。
 ```c++
 int rats=101;
 int *pt=&rats;
 int &rodent=*pt;
 int bunnies=50;
 pt=&bunnies;
```
 将rodent初始化为\*pt使得rodent指向rats，接下来将pt改为指向bunnies，并不能改变这样的事实。
## 将引用作为函数参数
 引用常被作为函数参数，使得函数中的变量名称为调用程序中变量名的别名。这种传递参数的方法被称为按引用传递。
 ```c++
void swapr(int &a,int &b);
void swapr(int *p,int *q);
void swapr(int a,int b);
```
## 引用的属性和特别之处
```c++
double cube(double a);
double refcube(double &a);
```
refcube函数修改了main()中的x值，而cube()没有，这提醒了我们为何通常按值传递。如果想要让函数使用传递给它的信息，而不对这些信息进行修改就需要使用引用常量。
```c++
double refcube(const double &a);
```
如果编写的函数传递的是基本数据类型，那么采用按值传递的方法，而如果传递的是一些结构或者对象，那么引用常量将会很有用。
如果将与上面类似的参数传递给接受引用参数的函数，传递引用的限制将会更加严格
```c++
double z=refcube(x+3.0);
```
这个代码不合法，因为表达式x+3.0的值不是引用。 
### 临时变量、引用参数和const
如果实参与引用参数不匹配，C++将会生成临时变量，如果引用参数是const那么C++编译器将在下面这两种情况下创建临时变量。
1. 实参的类型正确，但不是左值
2. 实参的类型不正确，但是可以被转换成正确的类型
左值参数是可以被引用的数据对象，例如，变量、数组元素、结构成员、引用和解除引用用的指针都是左值。非左值包括字面常量和包含多项的表达式 。在C语言中，左值最初指可以出现在赋值语句左边的实体，但是这是引入const之前的情形。现在，常规变量和const变量都可以被视为左值，因为可以通过地址来访问他们。但是常规变量属于可以修改的左值，const变量属于不可以修改的左值。
```c++ 
long edge=5;
double side=1.0;
double c1=refcube(edge);
double c2=refcube(7.0);
double c3=refcube(side+1.0);
```
edge虽然是变量，类型却不正确，double引用不能指向long。另一方面，虽然7.0和side+1.0类型正确，但他们都没有名称，在这些情况下，编译器都将生成一个临时的匿名变量，并让ra指向它。这些临时变量只在函数调用期间存在，此后编译器将它任意删除。

---
[[第7章：函数#指针和const|跟指针类似]]如果你尝试将const引用给非const引用初始化，编译器就会报错，这是因为const引用的使用范围更加严格，它保证了被引用对象的只读性。如果允许使用const引用给非const引用初始化，呢么通过这个非const引用就能修改const引用所引用的对象，违反了const的定义
```c++
int i = 10;
int &iref = i;
const int &irefc = iref;

```
---
关于这个临时对象是否被回收，通过以下程序进行了测试：
```c++
const double * func1(const double & refi);
int main(){
    auto a1=func1(12);
    std::cout<<"a1 is "<<*a1<<" a1 is in "<<a1;
}
const double * func1(const double & refi){
    std::cout<<"refi is : "<<refi<<std::endl;
    std::cout<<" refi is in "<<&refi<<std::endl;
    return &refi;
}```
通过程序的结果可以看出临时对象所指向的呢个地址的内存空间并没有被释放，但是这个结论是否正确仍然是一个 #疑点

### 尽可能的使用const 变量
1. 使用const变量可以避免无意中修改数据的变成错误；
2. 使用const变量能够使函数处理const类和非const类，否则只能接受非const数据；
### 右值引用
C++新增了一种引用——右值引用，这种
引用可以指向右值，是使用&&声明的。
```c++
double &&rref=std::sqrt(36.00);
double j=15.0;
double &&jref=2.0*j+18.5;
```
新增右值引用的主要目的是，让库设计人员能够提供有些操作更有效的实现。
## 将引用用于结构
```c++
 #include<iostream>
#include<string>
struct free_throws{
    std::string name;
    int made;
    int attempts;
    float percent;
};

void display(const free_throws &ft);
void set_pc(free_throws &ft);
free_throws & accumulate(free_throws & target, 
const free_throws & source);
int main(){
    free_throws one={"Ifelsa Branch",13,14};
    free_throws two={"Andor Kontt",10,6};
    free_throws three={"Minnie Max",7,9};
    free_throws four={"Whily Looper",5,9};
    free_throws five={"Long Long",6,14};
    free_throws team={"Throwgoods",0,0};
    free_throws dup;

    set_pc(one);
    display(one);
    accumulate(team,one);
    display(team);
    display(accumulate(team,two));
    accumulate(accumulate(team,three),four);
    display(team);
    dup=accumulate(team,five);
    std::cout<<"Displaying dup after assignment:\n";
    display(dup);
    return 0;

}
void display(const free_throws &ft){
    using std::cout;
    cout<<"Name: "<<ft.name<<'\n';
    cout<<"made: "<<ft.made<<'\n';
    cout<<"attempts: "<<ft.attempts<<'\n';
    cout<<"Percent: "<<ft.percent<<'\n';

}
void set_pc(free_throws &ft){
    if(ft.attempts!=0)
        ft.percent=100.0f*float(ft.made)/float(ft.attempts);
    else
        ft.percent=0;
}
free_throws & accumulate(free_throws & target, 
const free_throws & source){
    target.attempts+=source.attempts;
    target.made+=source.made;
    set_pc(target);
    return target;
}
```
返回引用最重要的一点就是应避免函数终止时不存在的内存单元引用。
```c++
const free_throws & clone2(free_throws & ft)
{
	free_throws newguy;
	newguy=ft;
	return newguy;
}
```
该函数指向一个临时变量的引用，函数运行结束后将不复存在。为了避免这种问题，最简单的方法就是**返回一个作为参数传递给函数的引用**。另一种方法是使用new来为字符串分配内存单元
```c++
const free_throws & clone(free_throws & ft){
	free_throws *pt;
	*pt=ft;
	return *pt;
}
 ```
 ### 为何将const用于引用返回类型
 上面的程序包含
 ```c++
 accumulate(dup,five)=four;
 ```
 这样的语句。在赋值语句中，左边必须是可以修改的左值。也就是说，在赋值表达式中，左边的子表达式必须标识一个可以修改的内存块。在这里，函数返回指向dup的引用，他确实标识的是一个这样的内存块。另一方面常规返回值的类型是右值——不能通过地址访问的值。这种表达式可能出现在赋值语句的右边，但是不能出现在左边。常规函数的返回值都位于临时的内存单元中，因此常规函数的返回值都是右值，运行下一条语句他可能不再存在
假设要使用引用返回值，但又不允许给返回值赋值这种操作，只需要将返回值类型声明为const引用。
```c++
cosnt free_throws &
	accumulate(free_throws & target,const free_throws &source);
	```

## 将引用用于类对象
```c++
const string &version1(const string &s1,const string &s2){
	string temp;
	temp=s2+s1+s2;
	return temp;
}
```
这里有三个版本的函数，version1最简单
```c++
string version1("***",*+++*);
```
当传入的是两个字符串字面值的时候，由于const引用的[[第8章：函数探幽#临时变量、引用参数和const|转换特性]]，这条语句合法。
```c++
const string &version2(string &s1,const string &s2){
	s1=s2+s1+s2;
	return s1;
}
```
version2直接修改原来的对象。
```c++
const string &version3(string &s1,const string &s2){
	string temp;
	temp=s1+s2+s1;
	return temp;
}
```
version3指出了什么不能做，返回值一个version3（）声明变量的引用。
## 对象、引用和继承
继承的一个特性是，基类引用可以指向派生类对象，而无需强制类型转换。因此可以定义一个**接受基类引用作为参数**的函数，在调用该函数的时候可以将基类对象作为参数，也可以将派生类对象作为参数。
例如，ostream是基类，而ofstream是派生类，参数类型ostream&的函数可以接受ostream对象和ofstream类型的对象。
```c++
void file_it(ostream &os){
	os<<"It's the content"<<'\n';
}
```
## 何时使用引用参数
使用引用参数的原因主要有两个：
- 能直接修改实参
- 通过传递引用，提高效率
当数据对象较大的时候我们可以使用引用传递，有些情况要使用值传递，下面是一些指导原则：
- 数据很小则值传递
- 如果数据对象是数组，则只能使用指针
- 如果数据对象比较大，则选择const引用和const指针
对于修改调用函数数据的函数：
- 如果数据类型是内置数据类型，则使用指针
- 如果数据对象是数组，则只能使用指针
- 如果数据对象是类对象，则使用引用
# 默认参数
默认参数必须在函数原型中被设置，而且只有函数原型设置默认参数 ，函数定义与没有默认参数时完全相同。
```c++
func(int n=1);
```
参数列表有多个的情况下也能设置默认参数，但是实参需要按从左到右的顺序依次被赋给相应的形参，而不能跳过任何参数。
```c++
func(int i=1,int j=1,int k=1);
...
func(10);//=func(10,1,1)
func(10,11);//=func(10,11,1)
func(10,,12);//invalid
```

```c++
#include <iostream>
const int ArSize = 80;
char* left(const char* str, int n = 1);
int main() {
	using namespace std;
	char sample[ArSize];
	cout << "Enter string:\n";
	cin.get(sample, ArSize);
	char* ps = left(sample, 4);
	cout << ps << endl;
	delete[]ps;
	return 0;
}
char* left(const char* str, int n) {
	if (n < 0) n = 0;
	char* p = new char[n + 1];
	int i;
	for (i = 0; i < n && str[i]; i++) p[i] = str[i];
	while (i <= n) p[i++] = '\0';
	return p;
}
```
# 函数重载
函数重载的关键是函数的参数列表，也被称作函数特征标。函数重载的意思是两个函数的名称相同，但是函数的特征标不同，例如：
```c++
void print(const char *str,int width);
void print(double d,int width);
void print(long l,int width);
void print(int i,int width);
```
在调用函数的时候，首先要匹配函数名，匹配到函数名之后，根据参数类型匹配原型，如果没有匹配的原型，使用强制类型转换进行匹配。引用是不能和类型本身共存的，他们的特征标看似不同，但是传递完参数后编译器无法区分。
匹配函数时要注意区分const和非const变量，例如：
```c++
void func(char *bits);
void func(const char *cbits);
void func1(char *bits);
void func2(const char *cbits);

const char p1[10];
char p2[10];
func(p1);//void func(const char *cbits);
func(p2);//void func(char *bits);
func1(p1);//no match
func1(p2);//void func1(char *bits);
func2(p1);//void func2(const char *cbits);
func2(p2);//void func2(const char *cbits);
```
这里函数重载的匹配跟之前讲到的[[第7章：函数#^f3b335|const与指针]]有关系，将非const赋给const是非法的。
请注意，函数的返回值类型并不能构成重载。想要重载两个返回值不同的函数，特征标也必须不同。
## 重载引用参数
```c++
void sink(double &r1);
void sink(const double &r2);
void sink(double &&r3);
```
左值引用参数r1可以与可修改的左值参数匹配；const左值引用参数r2与可修改的左值参数、const左值和右值匹配；右值引用r3与右值匹配。注意到r1或r3匹配的类型与r2都匹配，那么当重载这三种不同类型的函数时，结果将会怎么匹配呢？答案是调用最匹配的版本。
```c++
double b1=1.0;
const double b2=2.0;
sink(b1);//r1
sink(b2);//r2
sink(b1+b2);//r3
```
## 名称修饰（名称矫正）
编译器根据函数原型中指定的形参类型对每个函数进行加密。下面是要给未经修饰过的函数原型：
```c++
long MyFunctionFoo(int,float);
```
编译器将其转换为内部表示：
``` c++
?MyFunctionFoo@@YAXH
```
编译器将对参数数目和类型进行编码，添加的符号随着函数的特征标而异。
# 函数模板
函数模板允许以任意类型的方式定义函数，例如：
```c++
template<typename AnyType>
void swap(AnyType &a,AnyType &b){
	AnyType temp;
	temp=a;
	a=b;
	b=temp;
}
```
在c++98添加关键字typename之前，C++使用关键字class来创建模板，但是有很多函数库都是用class来定义的，因此为了区别引入了template。
函数模板不可能缩短可执行程序，当传递不同类型的参数的时候，编译器也会创建两个不同的函数和函数原型，就像手工定义函数一样。处理过的代码不包含任何模板，只包含为了程序而生成的实际函数。
## 重载函数模板
和常规函数一样，函数模板的函数特征标必须不一样，例如：
```c++
template<typename T>
void swap(T &a,T&b){...}
void swap(T a[],T b[],int n){...}
```
## 显式具体化
编写函数的模板可能无法处理某些类型，比如有赋值操作，如果定义了数组的函数，那么将不合法；有比较运算符，如果定义了结构的函数，那么也不合法。一种解决方法是，重载运算符，另一种解决方法是，为特定类型提供特定的具体化的模板定义。
对于非模板函数、模板函数和具体化模板函数C++有下面的要求：
- 对于给定的函数名，可以有非模板函数、模板函数和具体化模板函数以及他们的重载版本
- 显示具体化的原型和定义以template<>开头，并通过名称来指出类型
- 具体化优先于常规模板，非模板函数优先于具体化
```c++
struct job{...}

void swap(job &,job &);
template<typename T>
void swap(T &,T&);
template<>void swap<job>(job &,job &);

template<>void swap<job>(job &,job &){
	...
}
```
其中，`template<>void swap<job>(job &,job &);`的\<job>是可选的，因为函数的参数类型表明，这是job的一个具体化。
## 具体化和实例化
在代码中包含函数模板本身并不会生成函数定义。使用模板为特定类型生成函数定义时，会得到模板实例。例如，函数调用swap(i,j)导致编译器生成swap的一个实例，该实例使用int类型。模板并非定义，但是使用int的模板实例是定义，这种实例化方法叫做**隐式实例化**。
C++还包括**显式实例化**这意味着可以直接用命令编译器创建特定的实例。其语法是用\<>声明所需要的种类，并在声明前加上关键字template：
```c++
template void swap<int>(int &,int &);
```
使用了这种声明之后，编译器将使用swap模板直接生成一个int实例。
```c++
template<>void swap<job>(job &,job &);
```
显式具体化和显式实例化看起来很相似，但是其表达的意思不同。显式具体化的意思是不要使用swap常规模板来生成函数定义，而应该使用专门为job类型显式定义的函数定义。另一点是二者的语法不同，显式具体化在template后面有一个\<>。
值得注意的是，显式实例化和显式具体化不能对同一类型使用。可以现象，swap模板的显式实例化生成了一个int类型的函数模板实例，而swap模板的显式具体化生成了一个int类型的函数模板实例，这就导致相同的函数有两个定义，编译器会报错。
## 函数解析
函数重载、函数模板和函数重载模板要求C++有一个良好的策略来决定为函数调用使用哪个定义。这个过程称作函数解析，通常包括下面的步骤：
1. 创建候选函数列表：其中包括与调用函数名称相同的函数和函数模板
2. 使用候选函数列表创建可行函数列表。例如，使用float参数的函数能够转换为double使其与形参double匹配，而模板可以为float生成一个实例
3. 确定是否有最佳可行函数，如果有则选择它，否则函数调用将报错。
通常匹配由最佳到最差如下所述：
1. 完全匹配，但常规函数优先于模板
2. 提升转换
3. 标准转换
4. 用户定义的转换，类中声明的转换
### 完全匹配和最佳匹配
C++允许一些无关紧要的转换。如下表：

| 从实参                 | 到形参                    |
|---------------------|------------------------|
| type                | type&                  |
| type&               | type                   |
| type[]              | type*                  |
| type(argument-list) | type(*)(argument-list) |
| type                | const type             |
| type                | volatile type          |
| type*               | const type             |
| type*               | volatile type          |

如果有多个最佳匹配的原型会造成ambiguouos（二义性）的报错，但是也有例外。首先，指向非const数据的指针和引用优先与非const指针和引用参数匹配，要注意这一条只适用于引用和指针；另一个就是，一个是模板而另一个不是。
如果两个完全匹配的函数都是模板，则更具体的那个优先。
## decltype在函数模板中的应用
在编写函数模板中会遇到下面的情况：
```c++
template<class T1,class T2>
vodi ft(T1 x,T2 y){
...
type? xpy=x+y;
...
}
```
这就需要使用decltype，`decltype(expression) var`。decltype的检查分为4步：
1. 如果expression是一个没有用括号括起标识符，则var的类型与该标识符的类型相同，包括const限定符；
2. 如果expression是一个函数调用，则var的类型与函数的返回值相同，在这个过程中，并不需要调用函数，编译器只是查看函数返回值类型；
3. 如果expression是一个左值，则var为指向其类型的引用。
```c++
double x=3;
decltype((x)) w=x;//w is double &
```
4. 如果前面的条件都不满足，则var的类型与expression类型相同
## 后置返回类型
还有一个问题是decltype无法解决的：
```c++
template<class T1,class T2>
type? gt(T1 x,T2 y){
	return x+y;
}
```
可以把返回值类型声明成`decltype(x+y)`，但是不幸的是此时还未声明x和y。必须在声明参数之后使用decltype。
为了解决这个问题cpp新增了一个语法：
```c++
auto gt(T1 x,T2 y)->decltype(x+y){
...
return x+y;
}
```

