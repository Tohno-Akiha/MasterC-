---
类型: " 笔记"
时间: 2024-01-22T11:08:00 
父类标识: C++ prime plus笔记
---

# 函数的基本知识
要使用函数必须完成这三个步骤：提供函数定义，提供函数原型，调用函数
```c++
#include<iostream>
void simple();//function prototype
int main(){
	using namespace std;
	cout<<"main() will call the simple() function:\n";
	simple();//function call
	cout<<"main() is finished with the simple() function.\n";
	return 0;
}
//function definition
void simple(){
	using namespace std;
	cout<<"I'm but a simple function\n";
}
```
## 定义函数
函数分为两类：有返回值的和没有返回值的。没有返回值的称为**void函数**，其通用格式如下：
```c++
void functionName(parameterList){
	statement(s)
	return;//optional
}
```
有返回值的函数将生成一个值，并将它返回给调用函数，其通用格式如下：
```c++
typeName functionName(parameterList){
	statement(s)
	return typeName;
}
```
对于有返回值的函数必须使用返回语句，以便将值返回给调用函数。值本身可以是变量、常量、表达式，只是其结果的类型必须是typeName类型，或者可以被转换成typeName类型。cpp对于返回值的类型有一定的限制：不能是数组，但是可以使其他任何类型——整数、浮点数、指针，甚至可以是结构和对象，有趣的是cpp虽然不允许数组作为返回值，但是可以将数组作为结构和对象的组成部分返回。
通常，函数通过将返回值复制到指定的cpu寄存器或内存单元中将其返回。随后，调用程序将查看该内存单元。调用函数和返回函数必须就内存单元中存储的数据的类型达成一致，函数原型将返回值类型告知调用程序，而函数定义命令被调用的函数返回什么类型的数据。
```c++
double cube(double x);
...
int main(){
	...
	double q=cube(1.2);//main在此处寻找返回值，将它赋给q；cube（）原型告诉mian（）可以获得double类型
	...
}
double cube(double x){
	return x*x*x;//cube计算返回值，将它置于此处；函数头告诉cube要使用double类型的值
}
```
## 函数调用和函数原型
1. 为什么需要原型？
原型描述了函数到编译器的接口，也就是说它将函数返回值的类型和参数的类型和数量告诉编译器。
为何编译器需要原型，难道就不能让它在文件中进一步查找，以了解函数是如何定义的吗？这种方法的一个问题是效率不高，编译器在搜索文件的时候必须停止对main函数的编译。一个更严重的问题是，函数甚至可能不在文件中。避免使用函数原型的唯一方法是，在首次使用函数之前定义它，但这并不总是可行的。
2. 原型的语法
函数原型是一条语句，必须以分号结尾。获得函数原型最简单的方法就是，复制函数定义中的函数头，并添加分号。然而函数原型并不要求提供变量名，有类型列表就足够了。
3. 原型的功能
函数原型可以极大地降低程序出错的机率，具体来说原型确保以下几点：
	- 编译器正确处理函数返回值
	- 编译器检查使用的参数数目是否正确
	- 编译器检查使用的参数类型是否正确；如果不正确，则转换为正确的类型
# 函数参数和按值传递
函数通常按值传递，这意味着将数值参数传递给函数，而后者将其赋给一个新的变量。一般使用参数（argument）来表示实参，使用 参量（parameter）来表示形参。
# 函数和数组
```c++
#include<iostream>
const int ArSize=8;
int sum_arr(int arr[],int n);
int main(){
    using namespace std;
    int cookies[ArSize]={1,2,4,8,16,32,64,128};
    int sum=sum_arr(cookies,ArSize);
    cout<<"Total cookies eaten: "<<sum<<"\n";
    return 0;
}
int sum_arr(int arr[],int n){
    int total=0;
    for(int i=0;i<n;i++) total+=arr[i];
    return total;
}
```
## 函数如何使用指针来处理数组
cpp将数组名解释为第一个元素的地址：
```c++
cookies==&cookies[0]
```
该规则有一些例外：数组声明使用数组名来标记存储位置；对数组名使用sizeof将得到整个数组的长度；将地址运算符&用于数组名时，将返回整个数组的地址。
需要注意的是，在cpp中当且仅当用于函数头或者函数原型时，int\*arr和int arr[]的含义是相同的。
## 将数组作为参数意味着什么
在本例中，sum_arr将数组的地址传递给赋给arr，这意味着并没有将整个数组的内容传递给函数。这种方法可以节省复制整个数组所需要的时间和内存空间，但是使用原始数据增加了破坏数据的风险，可以使用const来解决这个问题。
cookies和arr指向同一个地址，但是对他们使用sizeof运算符结果是不一样的，因为函数中接收数组的这个参量是以int类型指针的方式声明的，这也就是为什么需要显式的指出数组的长度n：指针本身并没有指出数组的长度。
由于sum_arr函数只能通过第二个参数来获得数组的长度，因此可以假的函数初始位置和假的元素个数，如：
```c++
sum=sum_arr(cookies+4,4);
```
也可以将`&cookies[4]`作为参数，他们两个含义是相同的。
## 指针和const

^f3b335

将const用于指针有一些很微妙的地方，可以使用两种不同的方法将const关键字用于指针，第一种方法是让指针指向一个常量对象，第二种方法是将指针本省声明为const。
```c++
int age=39;
const int *pt=&age;
```
pt指向一个const int，因此不能通过pt来修改这个值。但是pt的声明并不意味着它指向的值实际上就是一个常量，而是说对于pt而言，这个值就是一个常量。
```c++
age=20;//valid
*pt=20;//invalid
```
上面我们把常规变量的地址赋给指针，将const变量的地址赋给常规指针也是合法的，但是将const的地址赋给常规指针就是不合法的
```c++
const float g_earth=9.8;
const float *pe=&g_earth;//valid

const float g_moon=1.63;
float *pm=&g_moon;//invalid
```
对于第一种情况来说，既不能通过pe来修改，也不能通过g_earth来修改。cpp禁止第二种情况的原因很简单，这回导致g_moon的const状态很荒谬：可以使用pm来修改g_moon的值，而不能通过g_moon自己来修改。
如果将指针指向指针，进入两级间接关系的时候将const和非const混合的指针赋值方式将不再安全。
```c++
const int **pp2;
int *p1;
const int n=13;
pp2=&p1;//const指针能够指向非const
*pp2=&n;//*pp2此时是const int *，const指向const
*p1=10;//此时p1虽然不是const指针但是指向const变量，还能修改const的值
```
因此，当且仅当只有一层间接关系的时候才能将非const地址或指针赋给const。注意：如果数据类型本身不是指针，则可以将const数据或者非const数据赋给指向const的指针，但非const指针只能接收非const数据。假如有一个const数据的数组：
```c++
const int months[12]={...};
...
int sum(int arr[],int n){
...
}
...
int j=sum(month,12)//not allowed
```
上述函数调用将const指针赋值给非const指针。因此如果条件允许一般都应将函数的形参声明为const。
# 函数和二维数组
```c++
int data[3][4]={{1,2,3,4},{9,8,7,6},{2,4,6,8}};
int total=sum(data,3);
```
data是一个数组名，第一个元素本身就是一个数组，因此data的类型就是指向由4个int组成的数组的指针，因此sum的函数原型如下：
```c++
int sum(int (*arr)[4],int size);
```
其中的括号是必不可少的，因为`int *arr[4]`声明的是由四个指向整型数组成的数组。
如何在函数中定义它呢，最简单的方法就是将arr看作是一个二维数组的名字：
```c++
int sum(int arr[][4],int size){
	int total=0;
	for(int r=0;r<size;r++){
		for(int c=0;c<4;c++) total+=arr[r][c];
	}
	return total;
}
arr[r][c]=*(*(arr+r)+c);
arr;//指向存放第0个一维数组地址的地址的指针
arr+r;//指向存放第r个一维数组的地址指针
*(arr+r)//指向的是第r个一维数组的地址，也就是这个一维数组的第一个元素
```
# 函数和C风格字符串
C风格字符串以一系列字符组成，以空置指针结尾，将字符串作为参数意味着传递的地址，但是可以用const来禁止对字符串进行修改。
## 将C风格字符串作为参数的函数
想要将C风格字符串传给函数有三种方式：char数组、用引号引起的字符串常量、被设置为字符串的地址的char指针。C风格字符串与字符数组的区别在于，C风格字符串有结束字符，这意味着**不需要将字符串长度作为参数传递给函数**。
```c++
unsigned int c_int_str(const *char str,char ch){
	unsigned int count=0;
	while(*str)) if(*(str++)==ch) count++;
	return count;
}
```
## 返回C风格字符串的函数
```c++
char * buildstr(char ch,int n){
	char *pstr=new char[n+1];
	char[n]='\n';
	while(n-->0) pstr[n]=c;
	return pstr;
}
```
需要注意的是，当该字符串不再需要的时候，应该使用delete释放该字符串占用的内存。然后，将ps指向为下一个字符串分配的内存块，然后再释放他们。
# 函数指针
与数据项一样，函数也有地址，可以编写一个将另一个函数地址作为参数的函数，这样第一个函数就能找到第二个函数。
## 函数指针的基础知识
1. 获取函数的地址：
使用函数名（后面不加参数即可）。`function()`是一个函数`function`就是它的函数地址。
 2. 声明函数指针：
声明函数指针的时候，应该声明指定的函数返回值类型以及函数的特征标（参数列表）。
```c++
double pam(int);//prototype
...
double (*pf)(int);
```
这与pam的声明类似，只是将pam替换成了(\*pf)，为了提供正确的优先级，必须使用括号将其括起
 3. 使用指针来调用函数
```c++
double pam(int);
double (*pf)(int);
pf=pam;
double x=pam(4);
double y=(*pf)(5);
```
实际上，cpp也允许像使用函数名一样使用pf：
```c++
double y=pf(5);
```
## 函数指针实例
```c++
#include <iostream>
double betsy(int);
double pam(int);
void estimate(int lines,double (*pf)(int));
int main(){
    using namespace std;
    int code;
    cout<<"How many lines of code do you need";
    cin>>code;
    cout<<"Here's Betsy's estimate:\n";
    estimate(code,betsy);
    cout<<"Here's Pam's estimate:\n";
    estimate(code,pam);
    return 0;
}
double betsy(int lns){
    return 0.05*lns;
}
double pam(int lns){
    return 0.03*lns+0.0004*lns*lns;
}
void estimate(int lines,double (*pf)(int)){
    using namespace std;
    cout<<lines<<" lines will take ";
    cout<<(*pf)(lines)<<" houres\n";
}
```



