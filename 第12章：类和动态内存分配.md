# 特殊成员函数
- 默认构造函数
- 默认析构函数
- 复制构造函数
- 赋值运算符
- 地址运算符
## 复制构造函数
复制构造函数用于将一个对象复制到新创建的对象中，它接受一个指向对象的引用常量作为参数。下面4种声明都会调用复制构造函数：
```c++
stringbad ditto(motto);
stringbad metoo=motto;
stringbad also=stringbad(motto);
stringbad *pstringbad=new stringbad(motto);
```
默认的复制构造函数逐个复制非静态成员（成员复制也称浅复制），静态成员不会被复制，它属于类。
## 深度复制字符串
通常我们平常使用的字符串复制都是浅复制，比如：
```c++
char *str1="Hello World";
char *str2=str1;
```
这种复制的结果就是，str1和str2都是指向的同一个字符串，而这个字符串被存放在堆内存中。在类中使用时，如果构造函数使用了new，那么在复制的时候如果析构函数会释放两次内存，因此我们需要深度复制。
```c++
string(const string&st){
	len=st.len;
	str=new char[len+1];
	std::strcpy(str,st.str);
}
```
## 赋值运算符与复制构造函数
与复制构造函数类似，赋值运算符的隐式形式也对成员进行逐个复制，如果成员本身就是类对象，则程序将使用为这个类定义的赋值运算符来复制该成员。但静态成员不受影响。
```c++
stringbad knot;
knot=motto;//赋值运算符
```
使用复制构造函数初始化一个变量可以分为两步，第一步是创建一个临时变量，第二步在使用赋值运算符：
```c++
stringbad knot=motto;
```
与复制运算符相同，赋值运算符也会碰上深度复制的情况：
```c++
stringbad & stringbad::operator=(const stringbad &st){
	if(&st==this){
		return *this;
	}
	delete []str;
	len=st.len;
	str=new char[len+1];
	std::strcpy(str,st.str);
	return *this;
}
```
如果地址不同函数将释放，str指向的内存，因为稍后将把一个新的字符串的地址赋给str，如果不释放，将会一直留在内存中。
## 静态类成员函数
使用关键字static可以将成员函数声明成静态的，静态成员函数不能使用this指针，只能静态数据成员。如果静态类成员是在公有部分被声明的，可以使用作用域解析运算符来调用它。
# 对象的返回
## 返回指向对象的引用
使用const引用能够提高效率，因为返回对象将调用复制构造函数，将其值复制到一个临时变量，而返回引用不会。
也有返回指向非const对象的引用，这种情况一般用于赋值运算符的重载和<<运算符的重载。前者这么做旨在提高效率，后者必须这么做。
## 返回对象
如果返回的对象是调用函数中的局部变量，则不应该按引用的方式返回它。因为它在执行完毕之后就被释放了，最后引用指向一个不存在的对象。这种情况下应该返回对象而不是引用。
函数返回时，复制构造函数将会创建一个临时的变量来表示返回值。
```c++
net=force1+force2;
force1+force2=net;
cout<<(force1+force2=net).magval()<<endl;
```
创建的这个临时对象，<mark style="background: #FF5582A6;">在表达式结束时才会被释放</mark>。
如果不允许这种行为，可以将返回值类型声明成const类型，这样就不允许他们的返回值进行赋值操作。
# 嵌套结构和类
在类声明中声明的结构、类或枚举， 它的作用域为类，如果声明是在私有部分进行的，则只能在这个类中使用。如果它是在公有部分声明的，则能够使用::运算符访问。
# 初始化列表语法
```c++
class test{
	const int a;
	const int b;
}
```
如果类中有const成员如何进行初始化？const变量只能在初始化的时候赋值，因此使用构造函数并不能修改const的值。c++提供了一种特殊的语法来完成这个工作，叫做成员列表初始化：
```c++
test::test(int i,int j):a(i),b(j){
	
}
```
在函数头括号后面使用冒号，相当于在构造函数执行前就给变量进行初始化，并且不光适用于常量，并且对于本身就是类对象的成员来说，这会使成员初始化列表的效率更高。