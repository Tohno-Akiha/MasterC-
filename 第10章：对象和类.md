# 类的定义
## 类规范
一般来说类由两个部分组成：
- 类声明：以数据成员的方式描述数据部分，以成员函数的方式描述公有接口。
- 类方法定义：描述如何实现类成员函数。
类成员分为私有和公有两种，私有成员只能被类自己的成员使用，而不能直接从程序中调用。
```c++
class stock{
private://private是类成员的默认访问控制，可以被省略
	float share;
	void set_tot(){...};
public:
	void buy();
	void sell();
}
```
## 实现类成员函数
成员函数定义和常规函数定义非常相似，他们有函数头和函数体，也有返回值和参数。但是有两个特殊的特征：
- 定义成员函数时，使用作用域解析运算符（：：）来标识函数所属的类。
- 类方法可以访问类的private组件。
## const成员函数
```c++
const stock land=stock("Kludgehorn Propertier");
land.show();
```
编译器会拒绝第二行，因为show()的代码无法保证调用对象无法被修改。但是show()没有任何参数，C++的解决方法是将const关键字放在括号后面。
```c++
void show() const;
```
# 类的构造函数和析构函数
## 声明和定义构造函数
```c++
stock(const string &co ,long n,double pr){
	company=co;
	if(n<0) share=0;
	else share=n;
	share_val=pr;
	set_tot();
}
```
## 使用构造函数
一种方法是显式的调用构造函数：
```c++
stock food=stock("World Cabbage",250,1.25);
```
另一种方式是隐式的调用构造函数：
```c++
stock food("World Cabbage",250,1.25);
```
使用new动态分配内存也会调用构造函数：
```c++
stock *food=new stock("World Cabbage",250,1.25);
```
## 默认构造函数
在未显式的提供初始值的时候，用来构造对象的构造函数。如果没有定义构造函数，cpp会自动提供构造函数，它是构造函数的隐式版本：
```c++
stock(){}
```
当然一也可以自己定义这个构造函数，但是一旦有了构造函数cpp就不再提供默认构造函数。
注意构造函数的隐式写法：
```c++
stock first("World Cabbage",250,1.25);
stock second();
stock third;
```
second()表示一个函数，并不表示构造函数。使用默认构造函数不能带括号。
## 析构函数
和构造函数一样，析构函数名也很特殊，在函数名前加上~。
```c++
~stock();
```
当对象被删除时，程序将调用析构函数。如果构造函数调用了new，那么析构函数必须使用提供delete的析构函数。
# this指针
this指针指向用于调用成员函数的对象。
# 对象数组
可以使用构造函数对对象数组进行初始化：
```c++
stock stock[4]={
	stock(...),
	stock(...),
	stock(...),
	stock(...)
}
```
# 类作用域
## 作用域为类的常量
```c++
class Bakery{
	private:
		const int months=12;
}
```
这种常量的定义方式是不行的，因为类声明只是描述了对象的形式，并没有创建对象。在创建对象之前没有用于存储值的空间。有两种方式可以实现这个目标。
第一种方式是在类中声明一个枚举：
```c++
class Bakery{
	private:
		enum{months=12};
}
```
使用这种方式不会创建数据成员，也就是说所有对象中都不包含枚举。
第二种方法是使用关键字static：
```c++
class Bakery{
	private:
		static const int months=12;
}
```
这将创建一个常量，该常量与所有其他静态变量都存储在一起。
## 作用域内枚举
传统的枚举存在一些问题，其中之一是两个枚举定义的枚举量会发生冲突。例如：
```c++
enum egg{Small,Large};
enum t_shirt{Small,Large};
```
这会发生冲突，为了避免这种问题，C++引入了一种新的枚举，其枚举量的作用域是类声明类似下面：
```c++
enum class egg{Small,Large};
enum class t_shirt{Small,Large};
```
也可以使用关键字struct替代class，无论使用哪种方式，都需要使用枚举名来限定枚举量：
```c++
egg choice=egg::Small;
t_shirt Floyd=t_shirt::Small;
```
作用域内枚举还提高了安全性，常规枚举能够被隐式转换成整型，而作用域内枚举不会。
